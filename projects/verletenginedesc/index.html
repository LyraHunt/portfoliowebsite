<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Verlet Engine</title>

    <link rel="stylesheet" href="/styles/reset.css">
    <link rel="stylesheet" href="/styles/style.css">
    <link rel="stylesheet" href="/styles/projectdescription.css">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,100;0,300;0,400;0,700;0,900;1,100;1,300;1,400;1,700;1,900&family=Playfair+Display:ital,wght@0,400..900;1,400..900&display=swap" rel="stylesheet">
</head>
<body>
    <div class="flex-column main-column">
        <div class="background-image-grapevine"></div>
        <div id="headerContainer"></div>

        <div class="main-content">
            <div class="flex-column">

                <div class="project-title-container fancy-border-project-title">
                    <h1 class="project-title">Verlet Engine</h1>
                    <h2 class="project-year">(2022)</h2>
                    <h2 id="visitCount">A physics simulation that implements Verlet integration.</h2>
                    <h2 class="project-margin-20-top"><a class="page-link-projects-verletengine" href="/">Run in Browser</a></h2>
                </div>

                <div class="project-column-60 project-margin-50-top text-box-shadow">
                    <p>
                        This project uses HTML canvas and a custom Javascript vector class to simulate ‘particles’ interacting in a deterministic way.
                        Although the colors of the particles may seem random at first, if you watch the simulation until the end you will notice that it is not as random as it seems.
                    </p>
                </div>

                <div class="project-column-60 project-margin-70-top text-box-shadow">
                    <h2 class="project-subtitle">Verlet Integration</h2>
                    <p>
                        Verlet integration is a way to simulate physics using a fixed time step.
                        This particular implementation doesn’t use any simulated velocity values; it only uses the previous frame’s position and the time passed to calculate the current velocity.
                        This is why this method is called Verlet <i>integration</i>, since the velocity (the derivative of the position) is calculated based on its integral rather than being calculated independently.
                    </p>
                </div>

                <div class="project-column-60 project-margin-70-top text-box-shadow">
                    <h2 class="project-subtitle">Collision Detection</h2>
                    <p>
                        This program simulates over 750 particles, so we have to be a little careful with how we detect the collisions.
                        The easiest solution would probably be to check each particle against every other particle, and then calculate if they are colliding based on that distance.
                        This works if you have 50 or even 100 particles, but once you get farther than that the program will start to really slow down.
                        This is because every frame we would be performing as many distance checks as the square of our particle count, or we could say that that algorithm has O(N^2) time complexity.
                    </p>
                    <p class="project-margin-20-top">
                        So, how do we simplify the collisions?
                        For this program, I chose to place all of the particles into a two-dimensional grid and then only check the other particles that are neighboring a particular cell in the grid.
                        For example, if we have a particle in position (5, 5) of our grid and another in (5, 6), we can tell that these particles are very close together and we can submit them to a list to be checked more thoroughly.
                        This program performs this process every frame.
                        Every frame the particles are placed into a grid, their proximity is checked, possible collisions are noted, collisions are then resolved, and then the particles are placed back into 2d space for the next simulation step.
                    </p>
                </div>
                <div class="project-column-80 project-margin-70-top text-box-shadow">
                    <h2 class="project-subtitle">Wrapping It Up</h2>
                    <p>
                        Each frame of the simulation follows this process:
                    </p>
                    <div class="project-margin-30-top" style="display: flex; justify-content: center;">
                        <ol>
                            <li>
                                Load particles from an array into a 2D grid based on their position.
                            </li>
                            <li>
                                Check if any particles have any closely neighboring particles.
                            </li>
                            <li>
                                Resolve any collisions between neighboring particles.
                            </li>
                            <li>
                                Load particles from the 2D grid back into an array.
                            </li>
                            <li>
                                Simulate each particle’s velocity based on how its position has changed.
                            </li>
                            <li>
                                Apply gravity to particles (move all particles downwards).
                            </li>
                            <li>
                                Constrain particle positions to be inside of the circular boundary.
                            </li>
                            <li>
                                Draw each particle according to its color and position.
                            </li>
                        </ol>
                    </div>
                </div>
                <div class="project-column-60 project-margin-70-top text-box-shadow">
                    <p>
                        That’s a lot to do in just one frame!
                        If you’re interested, you can check the Javascript files below to see how it’s implemented.
                        The verletengine.js file in particular has a lot of code comments to help explain the process.
                    </p>
                    <h2 class="project-subtitle project-margin-30-top">Source Code:</h2>
                    <div class="project-uncenter-children">
                        <p><a class="sourcecode-link-verletenginejs" href="/" target="_blank"><strong>verletengine.js</strong></a> - Contains the data, simulation, and rendering.</p>
                        <p class="project-margin-10-top"><a class="sourcecode-link-verletparticlejs" href="/" target="_blank"><strong>verletparticle.js</strong></a> - Contains the VerletParticle class.</p>
                        <p class="project-margin-10-bottom project-margin-10-top"><a class="sourcecode-link-vectorjs" href="/" target="_blank"><strong>vector.js</strong></a> - Contains the (messy) Vector class and helper math functions.</p>
                    </div>
                </div>
                <div class="project-margin-50-top text-box-shadow">
                    <h2><a class="page-link-workshop" href="/">Back to Workshop</a></h2>
                </div>
            </div>
        </div>

        <div id="footerContainer"></div>
    </div>

    <script src="/general_javascripts/load_globals.js"></script>
</body>
</html>